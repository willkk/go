Go 原理到进阶
2017-9-15

吴小川
CDN产品部


* Go 哲学

* Go 哲学
- 简单+可组合

简单：(routine)
每个代码片完成独立的，单一的功能。
代码片放到单独的一个goroutine里面执行。

可组合：(cocurrency)
简单的代码片可相互组合，完成整体功能。
组合的对象可以是struct，也可以是interface。

注：routine之间通信的通道是channel。

* Go原理

* Go原理
# 通用协程实现原理
*协程:*

1. 基于函数之间的长跳转setjmp/longjmp。
2. 函数栈分配在堆上，可动态伸缩。
3. 函数之间的上下文切换开销小。
.image images/go_threads.png
#https://stackoverflow.com/questions/5440128/thread-context-switch-vs-process-context-switch

* Go原理
# 当前go调度逻辑
*Go调度:*

 ┌─┐         ┌─┐         ┌─┐         ┌─┐                  ┌─┐
 │ │         │ │         │ │         │ │                  │ │
 ├─┤         ├─┤         ├─┤         ├─┤                  ├─┤ Global
 │ │         │G│         │ │         │ │                  │ │ state
 ├─┤         ├─┤         ├─┤         ├─┤                  ├─┤
 │G│         │G│         │G│         │ │                  │G│
 ├─┤         ├─┤         ├─┤         ├─┤                  ├─┤
 │G│         │G│         │G│         │G│                  │G│
 └┬┘         └┬┘         └┬┘         └┬┘                  └─┘
  │           │           │           │
  ↓           ↓           ↓           ↓
 ┌─┬──────┐  ┌─┬──────┐  ┌─┬──────┐  ┌─┬──────┐     ┌────┐┌──────┐┌───────┐
 │P│mcache│  │P│mcache│  │P│mcache│  │P│mcache│     │heap││timers││netpoll│
 └┬┴──────┘  └┬┴──────┘  └┬┴──────┘  └┬┴──────┘     └────┘└──────┘└───────┘
  │           │           │           │
  ↓           ↓           ↓           ↓
 ┌─┐         ┌─┐         ┌─┐         ┌─┐               ┌─┐ ┌─┐ ┌─┐
 │M│         │M│         │M│         │M│               │M│ │M│ │M│
 └─┘         └─┘         └─┘         └─┘               └─┘ └─┘ └─┘

G - goroutine; P - logical processor; M - OS thread (machine)

* Go原理
# go调度图示
地鼠搬砖：
.image images/gopher.png
进程启动的时候生成一个主Gopher（M），并最多生成GOMAXPROCS（不大于系统逻辑核心数）个小车（P）。go命令随后创建goroutine（书，G）。砖太多，小车空闲，就创建新的地鼠M去搬砖。
.image images/gopher2.png

* Go基础

* Go基础
- 基础语法
1.Go变量、结构体和函数声明及定义
变量声明：
.image images/gobase_var.png
#.code 

* Go基础
结构体声明：
.image images/gobase_typedef.png
#.code 

* Go基础
函数声明：
.image images/gobase_func.png
#.code

* Go基础
2.语句：
for语句：
.image images/gobase_for.png
#.code

* Go基础
defer语句：
.image images/gobase_defer.png
#.code

* Go基础
switch语句：
.image images/gobase_switch.png
#.code

* Go基础
switch语句：
.image images/gobase_select.png
#.code

* Go基础
3.包管理
代码行宽：
.image images/gobase_linewidth.png
#.code

* Go基础
变量及函数命名：
.image images/gobase_camel.png
#.code

* Go基础
包初始化：
.image images/gobase_initfunc.png
#.code

* Go基础
包文件及目录命名：
.image images/gobase_filedir.png
#.code

* Go基础
包目录结构：
.image images/gobase_pkgsubdir.png
#.code

* Go基础
- 数据类型
1.channel
FIFO同步内存队列，实现协程间数据通信。所以，内存效率高，多用，常用。另外，还可以用于goroutine的退出控制，close(chan)会立即让全部的管道接收操作返回。
2.map 
实现结构是hash，成员无序。空间换时间，内存占用较多，仔细考虑。go里面对应的tree实现是treemap库。
3.struct
struct匿名字段也叫嵌入字段，类似于C++的继承，字段名称为该类型名称。go会把嵌入字段的成员提升到当前结构体作用域。基类成员类型可以是结构体类型或其指针类型。在声明该结构体并同时初始化时，需要嵌套构造。结构体不能递归嵌套，不管直接或间接。外层字段会覆盖内层相同名称字段。规则：
1). 嵌入字段类型为结构体类型，子类类型可以访问基类或基类指针的方法集合；子类指针可以访问基类指针的方法集合。
2). 嵌入字段类型为结构体指针，子类类型及子类指针都可以访问基类及基类指针的方法集合。

* Go基础
4.interface&method
接口类型包括一个method集合。
只需要该类型或其指针实现该接口定义的方法集合即可。
任意类型都实现空接口对象interface{}。
一个类型可以同时实现多个接口。
接口类型也可以像结构体一样实现嵌入/继承，递归除外。
method可以定义在任何类型上，除了指针和interface接口。
比如，可以在一个函数上定义一个方法。参考http包HandlerFunc。

* Go基础
5.func(闭包closure)
.code codes/code.go /Compose/,/print\(Compose/
.code codes/adder.go /START1/,/STOP1/
.play codes/adder.go /START2/,/STOP2/

* Go基础
- Go并发模型
并发：同时处理很多事情。关于程序结构。
并行：同时在做很多事情。关于程序执行。
Go模型：把程序分解成可独立执行的单元（goroutine）；这些单元通过通信进行协作（channel）。

* Go基础
地鼠搬砖：一只地鼠
#Move a pile of obsolete language manuals to the incinerator.

.image images/gophersimple1.jpg

一个地鼠，时间比较久。
#With only one gopher this will take too long.

* Go基础
地鼠搬砖：多只地鼠
#* More gophers!

.image images/gophersimple3.jpg

地鼠够了，小车不够。
#More gophers are not enough; they need more carts.

* Go基础
地鼠搬砖：多只地鼠，多个小车
#* More gophers and more carts

.image images/gophersimple2.jpg

砖堆和窑会有瓶颈，还需要协调地鼠。
#This will go faster, but there will be bottlenecks at the pile and incinerator.
#Also need to synchronize the gophers.
#A message (that is, a communication between the gophers) will do.

* Go基础
地鼠搬砖：加倍砖堆和窑
#* Double everything

移除瓶颈
#Remove the bottleneck; make them really independent.

.image images/gophersimple4.jpg

当前的并发组合包含两个地鼠过程。
#This will consume input twice as fast.
#The concurrent composition of two gopher procedures.

* Go基础
并发组合
#* Concurrent composition

当前设计并不自动并行，但是自动可并行的。这也暗示了其他模型。

* Go基础
新的设计

.image images/gophercomplex0.jpg

三只地鼠，每个地鼠独立执行完成相同的工作，相互之间需要协调。

* Go基础
新的设计
#* Finer-grained concurrency
新加一只地鼠还车

.image images/gophercomplex1.jpg

比最初一只地鼠工作快4倍。

* Go基础
思考：
#* Observation

我们通过添加并发过程到当前设计来提高性能。

4种不同的并发过程：
#* Concurrent procedures
1.装载
2.运输
3.卸载
4.归还

不同的并发设计产生不同的并行化方式。

* Go基础
进一步并行化：八只地鼠
.image images/gophercomplex2.jpg
即使同时只有一只地鼠在工作，程序也是并发的。

* Go基础
另一种设计：两只地鼠+临时工作台
.image images/gophercomplex3.jpg

* Go基础
正常并行化：垂直

.image images/gophercomplex4.jpg

* Go基础
#* Or a different way
或者将临时工作台加入到多只地鼠的模型：水平
.image images/gophercomplex5.jpg

* Go基础
彻底优化：垂直+水平

.image images/gophercomplex6.jpg

* Go实战

* Go实战
- go 命令
1. go build
2. go install
3. go test
4. go run
5. go get
6. go tool (性能监控pprof)
7. go doc

* Go实战
- cgo
import "C"之前存放被注释的C代码。详细参考https://golang.org/cmd/cgo/。
使用cgo命令添加C编译选项，如// #cgo LDFLAGS: -L/go/src/foo/libs -lfoo。

* Go实战
- vendor目录
解决各个项目不同版本库代码冲突问题。
在src目录建立vendor目录，项目使用的特定版本库和不同源的包目录。
go优先去vendor目录搜索。

* Go实战
- 配置文件
推荐json格式的配置文件。定义：
.image images/goskill_jsonconf.png
注：可选字段为对应类型的指针类型。如果字段为空，指针为nil。

* Go实战
配置文件
.image images/goskill_jsonfile.png

* Go实战
使用：
.image images/goskill_jsonparse.png

* Go实战
- 函数：命名返回参数
普通代码：
.image images/goskill_func.png  600 800

* Go实战
使用命名返回参数：
.image images/goskill_func_new.png

* Go实战
- defer
普通代码：
.image images/goskill_nodefer.png

* Go实战
defer代码：
.image images/goskill_defer.png

* Go实战
- log库
seelog:
支持同步/异步（获取频率：循环，定时，自适应）；支持丰富的输出级别，格式，终端和颜色；支持不同级别log的文件过滤；支持log文件回滚；支持动态更新logger设置。
自定义：
runtime.Caller(1)返回调用函数所在的全文件路径名和行号；添加前缀log.SetPrefix(); os.Getpid()获取PID等。

* Go实战
好的log格式示例：
.image images/goskill_srslog.png  400  1000
说明：基本信息包括标识pid和tid，错误级别，错误号等。需要唯一标识每一个request。
错误号定义：分类定义，如http 1xx-5xx。

* Go实战
- web framework(beego, iris, martini)
Beego：使用MVC+ORM+RESTful，组件齐全，使用方便;框架比较臃肿，实现性能不高。
Iris: 速度最快的web framework，简单。
MVC：
.image images/goskill_mvc.png  400 500
思想：
将数据与表现解耦，提高代码的复用性。

* Go进阶

* Go进阶
- 面向过程
encoding/json:
.image images/goadvance_procdef.png

* Go进阶
- 面向对象
net/http包ServerMux:
.image images/goadvance_classservermux.png

* Go进阶
- 面向接口
hash:
.image images/goadvance_interfacehash.png

* Go进阶
接口定义：
.code codes/code.go /Interface1/,/Interface2/
接口实现：
.code codes/code.go /Interface2/,/Interface3/

* Go进阶
接口组合：
.code codes/code.go /Interface3/,/Interface4/
接口将数据和行为分离（class混合它们）
.code codes/code.go /HandlerFunc1/,/HandlerFunc2/

* Go进阶
接口使用：
.code codes/code.go /Interface4/,/Interface5/
链式组合：
.play codes/chain.go /LogReader{io/

* Go进阶
- 程序架构拆分（垂直+水平）
垂直：

 ┌──────────────────────────────────────────────────┐
 │                                                  │
 │                       App                        │
 ├─────┬────────┬─────────┬──────────┬────────┬─────┤
 │     │        │         │          │        │     │
 │     │        │         │          │        │     │
 │     │        │         │          │ outer  │     │
 │ log │ config │ message │ database │ invoke │ ... │
 │     │        │         │          │        │     │
 │     │        │         │          │        │     │
 │     │        │         │          │        │     │
 │     │        │         │          │        │     │
 └─────┴────────┴─────────┴──────────┴────────┴─────┘

* Go进阶
水平：

 ┌─────┬────────────────────────────────────────────┐
 │     │                                            │
 │     │                 access layer               │
 │     ├────────────────────────────────────────────┤
 │     │                                            │
 │     │            router/dispatcher layer         │
 │ App │────────────────────────────────────────────┤
 │     │                                            │
 │     │               handler layer                │
 │     ├────────────────────────────────────────────┤
 │     │                                            │
 │     │              database  layer               │
 └─────┴────────────────────────────────────────────┘

* Go进阶
- Redis 数据结构
Dict:(hash,链地址法)

 ┌──┐┌──┐┌──┐┌──┐      ┌──┐ 
 │k1││k2││k3││k4│ ...  │km│ M slots
 └──┘└──┘└──┘└──┘      └──┘
  ↓   ↓   ↓   ↓         ↓
 ┌─┐ ┌─┐ ┌─┐ ┌─┐       ┌─┐
 │v│ │v│ │v│ │v│       │v│
 ├─┤ ├─┤ └─┘ ├─┤       ├─┤
 │v│ │v│     │v│       │v│ 
 ├─┤ ├─┤     └─┘  ...  ├─┤ N conflicts
 │v│ │.│               │v│
 └─┘ │.│               └─┘
     │.│
     ├─┤
     │v│     
     └─┘      

* Go进阶
双buffer:
.code codes/code.go /Redis1/,/Redis2/
当M和N的比例达到一定阈值，进行rehash。rehash完成后，dict切换到新的hash指针。

* Go进阶


* Go进阶
- Mysql+ORM
定义：
.code codes/code.go /Model1/,/Model2/

* Go进阶
Create：
.code codes/code.go /Model2/,/Model3/
Retrieve:
.code codes/code.go /Model3/,/Model4/

* Go进阶
Update:
.code codes/code.go /Model4/,/Model5/
Delete:
.code codes/code.go /Model5/,/Model6/

* Go进阶
- RESTful/RPC

* Go进阶
- JWT(JSON Web Token)/OAuth2.0
.image images/goadvance_jwt.png

* Go进阶
OAuth2.0:




* Go进阶
- Docker/Kubernetes

