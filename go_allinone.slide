Go 原理到进阶
2017-9-15

吴小川
CDN产品部

* Go原理

* Go原理
# 通用协程实现原理
*协程:*

1. 基于函数之间的长跳转setjmp/longjmp。
2. 函数栈分配在堆上，可动态伸缩。
3. 函数之间的上下文切换开销小。
.image images/go_threads.png
#https://stackoverflow.com/questions/5440128/thread-context-switch-vs-process-context-switch

* Go原理
# 当前go调度逻辑
*Go调度:*

 ┌─┐         ┌─┐         ┌─┐         ┌─┐                  ┌─┐
 │ │         │ │         │ │         │ │                  │ │
 ├─┤         ├─┤         ├─┤         ├─┤                  ├─┤ Global
 │ │         │G│         │ │         │ │                  │ │ state
 ├─┤         ├─┤         ├─┤         ├─┤                  ├─┤
 │G│         │G│         │G│         │ │                  │G│
 ├─┤         ├─┤         ├─┤         ├─┤                  ├─┤
 │G│         │G│         │G│         │G│                  │G│
 └┬┘         └┬┘         └┬┘         └┬┘                  └─┘
  │           │           │           │
  ↓           ↓           ↓           ↓
 ┌─┬──────┐  ┌─┬──────┐  ┌─┬──────┐  ┌─┬──────┐     ┌────┐┌──────┐┌───────┐
 │P│mcache│  │P│mcache│  │P│mcache│  │P│mcache│     │heap││timers││netpoll│
 └┬┴──────┘  └┬┴──────┘  └┬┴──────┘  └┬┴──────┘     └────┘└──────┘└───────┘
  │           │           │           │
  ↓           ↓           ↓           ↓
 ┌─┐         ┌─┐         ┌─┐         ┌─┐               ┌─┐ ┌─┐ ┌─┐
 │M│         │M│         │M│         │M│               │M│ │M│ │M│
 └─┘         └─┘         └─┘         └─┘               └─┘ └─┘ └─┘

G - goroutine; P - logical processor; M - OS thread (machine)

* Go原理
# go调度图示
地鼠搬砖：
.image images/gopher.png
进程启动的时候生成一个主Gopher（M），并最多生成GOMAXPROCS（不大于系统逻辑核心数）个小车（P）。go命令随后创建goroutine（书，G）。砖太多，小车空闲，就创建新的地鼠M去搬砖。
.image images/gopher2.png

* Go基础

* Go基础
- 基础语法
1.Go变量、结构体和函数声明及定义
变量声明：
.image images/gobase_var.png
#.code 

* Go基础
结构体声明：
.image images/gobase_typedef.png
#.code 

* Go基础
函数声明：
.image images/gobase_func.png
#.code

* Go基础
2.语句：
for语句：
.image images/gobase_for.png
#.code

* Go基础
defer语句：
.image images/gobase_defer.png
#.code

* Go基础
switch语句：
.image images/gobase_switch.png
#.code

* Go基础
switch语句：
.image images/gobase_select.png
#.code

* Go基础
3.包管理
代码行宽：
.image images/gobase_linewidth.png
#.code

* Go基础
变量及函数命名：
.image images/gobase_camel.png
#.code

* Go基础
包初始化：
.image images/gobase_initfunc.png
#.code

* Go基础
包文件及目录命名：
.image images/gobase_filedir.png
#.code

* Go基础
包目录结构：
.image images/gobase_pkgsubdir.png
#.code

* Go基础
- 数据类型
1.channel
FIFO同步内存队列，实现协程间数据通信。所以，内存效率高，多用，常用。另外，还可以用于goroutine的退出控制，close(chan)会立即让全部的管道接收操作返回。
2.map 
实现结构是hash，成员无序。空间换时间，内存占用较多，仔细考虑。go里面对应的tree实现是treemap库。
3.struct
struct匿名字段也叫嵌入字段，类似于C++的继承，字段名称为该类型名称。go会把嵌入字段的成员提升到当前结构体作用域。基类成员类型可以是结构体类型或其指针类型。在声明该结构体并同时初始化时，需要嵌套构造。结构体不能递归嵌套，不管直接或间接。外层字段会覆盖内层相同名称字段。规则：
1). 嵌入字段类型为结构体类型，子类类型可以访问基类或基类指针的方法集合；子类指针可以访问基类指针的方法集合。
2). 嵌入字段类型为结构体指针，子类类型及子类指针都可以访问基类及基类指针的方法集合。

* Go基础
4.interface&method
接口类型包括一个方法集合，接口和实现类型之间不要求显式继承，只需要该类型或其指针实现该接口定义的方法集合即可。任意类型都实现空接口对象interface{}。一个类型可以同时实现多个接口。接口类型也可以像结构体一样实现嵌入/继承，递归除外。
method可以定义在任何类型上，除了指针和interface接口。比如，可以在一个函数上定义一个方法。参考http包HandlerFunc（类似只包含一个方法的匿名interface）。
5.func
闭包closure：
.code codes/code.go /Compose/,/print\(Compose/

* Go基础
- Go并发模型
并发：同时处理很多事情。关于程序结构。
并行：同时在做很多事情。关于程序执行。
Go模型：把程序分解成可独立执行的单元（goroutine）；这些单元通过通信进行协作（channel）。

* Go基础
地鼠搬砖：一只地鼠
#Move a pile of obsolete language manuals to the incinerator.

.image images/gophersimple1.jpg

一个地鼠，时间比较久。
#With only one gopher this will take too long.

* Go基础
地鼠搬砖：多只地鼠
#* More gophers!

.image images/gophersimple3.jpg

地鼠够了，小车不够。
#More gophers are not enough; they need more carts.

* Go基础
地鼠搬砖：多只地鼠，多个小车
#* More gophers and more carts

.image images/gophersimple2.jpg

砖堆和窑会有瓶颈，还需要协调地鼠。
#This will go faster, but there will be bottlenecks at the pile and incinerator.
#Also need to synchronize the gophers.
#A message (that is, a communication between the gophers) will do.

* Go基础
地鼠搬砖：加倍砖堆和窑
#* Double everything

移除瓶颈
#Remove the bottleneck; make them really independent.

.image images/gophersimple4.jpg

当前的并发组合包含两个地鼠过程。
#This will consume input twice as fast.
#The concurrent composition of two gopher procedures.

* Go基础
并发组合
#* Concurrent composition

当前设计并不自动并行，但是自动可并行的。这也暗示了其他模型。

* Go基础
新的设计

.image images/gophercomplex0.jpg

三只地鼠，每个地鼠独立执行完成相同的工作，相互之间需要协调。

* Go基础
新的设计
#* Finer-grained concurrency
新加一只地鼠还车

.image images/gophercomplex1.jpg

比最初一只地鼠工作快4倍。

* Go基础
思考：
#* Observation

我们通过添加并发过程到当前设计来提高性能。

并发过程：
#* Concurrent procedures
1.装载
2.运输
3.卸载
4.归还

不同的并发设计产生不同的并行化方式。

* More parallelization!

We can now parallelize on the other axis; the concurrent design makes it easy. Eight gophers, all busy.

.image images/gophercomplex2.jpg

* Or maybe no parallelization at all

Keep in mind, even if only one gopher is active at a time (zero parallelism), it's still a correct and concurrent solution.

.image images/gophercomplex2.jpg

* Another design

Here's another way to structure the problem as the concurrent composition of gopher procedures.

Two gopher procedures, plus a staging pile.

.image images/gophercomplex3.jpg

* Parallelize the usual way

Run more concurrent procedures to get more throughput.

.image images/gophercomplex4.jpg

* Or a different way

Bring the staging pile to the multi-gopher concurrent model:

.image images/gophercomplex5.jpg

* Full on optimization

Use all our techniques. Sixteen gophers hard at work!

.image images/gophercomplex6.jpg

* Go实战

* Go实战


* Go进阶

* Go进阶

